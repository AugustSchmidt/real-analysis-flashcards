<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Analysis Flashcards</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìö</text></svg>">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                processHtmlClass: 'tex2jax_process',
                ignoreHtmlClass: 'tex2jax_ignore'
            },
            startup: {
                typeset: false,
                ready: () => {
                    console.log('MathJax is loaded and ready');
                    MathJax.startup.defaultReady();
                }
            },
            loader: {
                load: ['[tex]/color', '[tex]/colorv2']
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-size: 18px;
            color: #666;
        }
        .error {
            color: red;
            padding: 20px;
            margin: 20px;
            border: 1px solid red;
            border-radius: 5px;
            background-color: #fee;
        }
        
        .celebration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        }
        
        .confetti {
            position: absolute;
            font-size: 20px;
            user-select: none;
            pointer-events: none;
        }
        
        .confetti-explode {
            animation-duration: 2.5s;
            animation-timing-function: ease-out;
            animation-fill-mode: forwards;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
            60% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.3);
            }
        }
        
        
        .confetti-bounce {
            animation: bounce 0.6s ease-in-out infinite;
        }
        
        .confetti-pulse {
            animation: pulse 1s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading">Loading comprehensive flashcards...</div>
    </div>

    <script>
        // Error handling
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Error: ', msg, '\nURL: ', url, '\nLine: ', lineNo, '\nColumn: ', columnNo, '\nError object: ', error);
            document.getElementById('root').innerHTML = '<div class="error">JavaScript Error: ' + msg + '</div>';
            return false;
        };
    </script>

    <script type="text/babel">
        try {
            const { useState, useEffect } = React;

            // Simple icons as text
            const ChevronLeft = () => '‚Äπ';
            const ChevronRight = () => '‚Ä∫';
            const RotateCcw = () => '‚Üª';
            const BookOpen = () => 'üìñ';
            const Check = () => '‚úì';
            const X = () => '‚úó';
            const Eye = () => 'üëÅ';
            const EyeOff = () => 'üëÅ‚Äçüó®';
            const Shuffle = () => 'üîÄ';
            const Moon = () => 'üåô';
            const Sun = () => '‚òÄÔ∏è';

            const flashcardsData = [
                // Section 1: Measures
                {
                    id: 1,
                    category: "Measures",
                    front: "Define an algebra of sets.",
                    back: "Let $X$ be a set. A subset $\\Sigma \\subset \\mathcal{P}(X)$ is an algebra of sets if:\\n\\n1. $X \\in \\Sigma$\\n\\n2. $\\Sigma$ is closed under absolute complements: If $A \\in \\Sigma$, then $X \\setminus A \\in \\Sigma$\\n\\n3. $\\Sigma$ is closed under binary unions: If $A, B \\in \\Sigma$, then $A \\cup B \\in \\Sigma$"
                },
                {
                    id: 2,
                    category: "Measures",
                    front: "What additional condition makes an algebra of sets into a $\\sigma$-algebra?",
                    back: "An algebra $\\Sigma$ is a $\\sigma$-algebra if it's closed under countable union: If $A_1, A_2, \\ldots \\in \\Sigma$ is a countable collection, then $\\bigcup_{k=1}^\\infty A_k \\in \\Sigma$"
                },
                {
                    id: 3,
                    category: "Measures",
                    front: "Define a measurable space.",
                    back: "A measurable space $(X, \\Sigma)$ consists of a set $X$ and a $\\sigma$-algebra $\\Sigma$."
                },
                {
                    id: 4,
                    category: "Measures",
                    front: "Define the $\\sigma$-algebra generated by $\\Sigma$.",
                    back: "Given an algebra of sets $\\Sigma$, the $\\sigma$-algebra generated by $\\Sigma$, denoted $\\sigma(\\Sigma)$, is the smallest $\\sigma$-algebra containing $\\Sigma$:\\n$$\\sigma(\\Sigma) = \\bigcap \\{ \\mathcal{F}\\subset \\mathcal{P}(X) : \\mathcal{F} \\text{ is a } \\sigma\\text{-algebra and } \\Sigma\\subset \\mathcal{F}\\}$$"
                },
                {
                    id: 5,
                    category: "Measures",
                    front: "Define the Borel $\\sigma$-algebra.",
                    back: "If $X$ is a topological space, the $\\sigma$-algebra generated by the family of open sets in $X$ is called the **Borel $\\sigma$-algebra** on $X$, denoted $\\mathcal{B}_X$. Its members are called **Borel sets**."
                },
                {
                    id: 6,
                    category: "Measures",
                    front: "What generates the Borel $\\sigma$-algebra on $\\mathbb{R}$?",
                    back: "The Borel $\\sigma$-algebra $\\mathcal{B}_\\mathbb{R}$ is generated by any of the following:\\n‚Ä¢ Open intervals: $\\{(a,b) : a < b\\}$\\n‚Ä¢ Closed intervals: $\\{[a,b] : a < b\\}$\\n‚Ä¢ Half-open intervals: $\\{(a,b] : a < b\\}$ or $\\{[a,b) : a < b\\}$\\n‚Ä¢ Open rays: $\\{(a,\\infty) : a \\in \\mathbb{R}\\}$ or $\\{(-\\infty,a) : a \\in \\mathbb{R}\\}$\\n‚Ä¢ Closed rays: $\\{[a,\\infty) : a \\in \\mathbb{R}\\}$ or $\\{(-\\infty,a] : a \\in \\mathbb{R}\\}$"
                },
                {
                    id: 7,
                    category: "Measures",
                    front: "Define a measure on a $\\sigma$-algebra $\\Sigma$.",
                    back: "A set function $\\mu: \\Sigma \\to [0,\\infty]$ is a measure if:\\n\\n1. $\\mu(\\emptyset) = 0$\\n\\n2. **Non-negative**: $\\mu(A) \\geq 0$ for all $A \\in \\Sigma$\\n\\n3. **Countable additivity**: For disjoint sets $A_1, A_2, \\ldots$, we have $\\mu\\left(\\bigcup_{k=1}^\\infty A_k\\right) = \\sum_{k=1}^\\infty \\mu(A_k)$"
                },
                {
                    id: 8,
                    category: "Measures",
                    front: "Define a measure space.",
                    back: "A measure space $(X, \\Sigma, \\mu)$ consists of a measurable space $(X, \\Sigma)$ and a measure $\\mu: \\Sigma \\to [0, \\infty]$."
                },
                {
                    id: 9,
                    category: "Measures",
                    front: "Define a $\\sigma$-finite measure.",
                    back: "A measure $\\mu$ on $(X, \\Sigma, \\mu)$ is $\\sigma$-finite if any of these equivalent conditions holds:\\n\\n1. $X$ can be covered by countably many measurable sets of finite measure\\n\\n2. $X$ can be covered by countably many **disjoint** measurable sets of finite measure\\n\\n3. $X$ can be covered by a **monotone sequence** of measurable sets of finite measure\\n\\n4. There exists a strictly positive measurable function $f$ with $\\int_X f \\, d\\mu < \\infty$"
                },
                {
                    id: 10,
                    category: "Measures",
                    front: "Define a premeasure.",
                    back: "Let $R$ be a ring of subsets of $X$. A function $\\mu_0: R \\to [0,\\infty]$ is a premeasure if:\\n\\n1. $\\mu_0(\\emptyset) = 0$\\n\\n2. **$\\sigma$-additivity**: For countable sequences $A_1, A_2, \\ldots \\in R$ of pairwise disjoint sets whose union is in $R$:\\n$$\\mu_0\\left( \\bigcup_{k=1}^\\infty A_k\\right) = \\sum_{k=1}^\\infty \\mu_0(A_k)$$"
                },
                {
                    id: 11,
                    category: "Measures",
                    front: "Define an outer measure.",
                    back: "An outer measure $\\mu^*: \\mathcal{P}(X) \\to [0,\\infty]$ is a function on the entire power set satisfying:\\n\\n1. $\\mu^*(\\emptyset) = 0$\\n\\n2. **Monotonicity**: If $A \\subseteq B$, then $\\mu^*(A) \\leq \\mu^*(B)$\\n\\n3. **Countable subadditivity**: For arbitrary subsets $A_1, A_2, \\ldots \\in \\mathcal{P}(X)$:\\n$$\\mu^* \\left( \\bigcup_{k=1}^\\infty A_k\\right) \\leq \\sum_{k=1}^\\infty \\mu^* (A_k)$$"
                },
                {
                    id: 12,
                    category: "Measures",
                    front: "Define the outer measure induced by a premeasure.",
                    back: "The outer measure induced by a premeasure $\\mu_0: R \\to [0,\\infty]$ is:\\n$$\\mu^*(A) = \\inf \\left\\{ \\sum_{k=1}^\\infty \\mu_0(A_k) : A_k \\in R \\text{ and } A \\subseteq \\bigcup_{k=1}^\\infty A_k\\right\\}$$"
                },
                {
                    id: 13,
                    category: "Measures",
                    front: "Define a $\\mu$-measurable set.",
                    back: "We say $E \\in \\mathcal{P}(X)$ is $\\mu$-measurable if:\\n$$\\mu(A) = \\mu(A \\cap E) + \\mu(A \\setminus E)$$\\n for all $A \\in \\mathcal{P}(X)$."
                },
                {
                    id: 14,
                    category: "Measures",
                    front: "State the basic properties of measures.",
                    back: "Let $(X, \\Sigma, \\mu)$ be a measure space. Then:\\n\\n‚Ä¢ **Monotonicity**: If $A \\subseteq B$, then $\\mu(A) \\leq \\mu(B)$\\n\\n‚Ä¢ **Subadditivity**: $\\mu\\left( \\bigcup A_k\\right) \\leq \\sum \\mu(A_k)$\\n\\n‚Ä¢ **Continuity from below**: If $A_1 \\subseteq A_2 \\subseteq \\cdots$, then $\\mu\\left( \\bigcup A_k\\right) = \\lim_{k\\to \\infty} \\mu(A_k)$\\n\\n‚Ä¢ **Continuity from above**: If $A_1 \\supseteq A_2 \\supseteq \\cdots$ and $\\mu(A_1) < \\infty$, then $\\mu\\left( \\bigcap A_k\\right) = \\lim_{k\\to \\infty} \\mu(A_k)$"
                },
                {
                    id: 15,
                    category: "Measures",
                    front: "State Carath√©odory's Extension Theorem.",
                    back: "Let $\\mu_0: \\Sigma_0 \\to [0,\\infty]$ be a premeasure on an algebra $\\Sigma_0$. Then $\\mu_0$ extends to a measure $\\mu$ on $\\sigma(\\Sigma_0)$ via:\\n\\n1. Extend $\\mu_0$ to outer measure $\\mu^*$\\n\\n2. Restrict $\\mu^*$ to the collection of $\\mu^*$-measurable sets\\n\\n3. Verify this collection contains $\\Sigma_0$\\n\\n If $\\mu_0$ is $\\sigma$-finite, the extension is unique."
                },
                
                // Section 2: Integration
                {
                    id: 16,
                    category: "Integration",
                    front: "When is a function $f: X \\to Y$ measurable?",
                    back: "A function $f: (X, \\Sigma_1) \\to (Y, \\Sigma_2)$ is measurable if for each $B \\in \\Sigma_2$, we have $f^{-1}(B) \\in \\Sigma_1$."
                },
                {
                    id: 17,
                    category: "Integration",
                    front: "Define the characteristic function of a set $A$.",
                    back: "The characteristic function $\\mathbf{1}_A(x)$ of $A$ is:\\n$$\\mathbf{1}_A(x) = \\begin{cases} 1 & \\text{if } x \\in A \\\\ 0 & \\text{if } x \\notin A \\end{cases}$$\\n\\n**Note**: $\\mathbf{1}_A$ is measurable $\\Leftrightarrow A \\in \\Sigma$"
                },
                {
                    id: 18,
                    category: "Integration",
                    front: "Define a simple function.",
                    back: "A simple function is a finite linear combination of characteristic functions of measurable sets:\\n$$\\phi = \\sum_{k=1}^n a_k \\mathbf{1}_{A_k}$$\\n where $a_k \\in \\mathbb{C}$ and $A_k \\in \\Sigma$.\\n\\n Equivalently: $f$ is simple $\\Leftrightarrow$ $f$ is measurable and has finite range."
                },
                {
                    id: 19,
                    category: "Integration",
                    front: "Define the integral of a simple function.",
                    back: "If $\\phi$ is a simple function with standard representation $\\phi = \\sum_{k=1}^n a_k \\mathbf{1}_{A_k}$, then:\\n$$\\int \\phi \\, d\\mu = \\sum_{k=1}^n a_k \\mu(A_k)$$"
                },
                {
                    id: 20,
                    category: "Integration",
                    front: "Define the integral of a non-negative measurable function.",
                    back: "For $f \\in L^+$ (non-negative measurable functions), the integral is:\\n$$\\int f \\, d\\mu = \\sup \\left\\{ \\int\\phi \\, d\\mu : 0\\leq \\phi \\leq f, \\phi \\text{ simple} \\right\\}$$"
                },
                {
                    id: 21,
                    category: "Integration",
                    front: "Define the integral of a real-valued measurable function.",
                    back: "For $f: X \\to \\mathbb{R}$, if at least one of $\\int f^+$ or $\\int f^-$ is finite:\\n$$\\int f \\, d\\mu = \\int f^+ \\, d\\mu - \\int f^- \\, d\\mu$$\\n where $f^+$ and $f^-$ are the positive and negative parts of $f$.\\n\\n$f$ is **integrable** when both $\\int f^+$ and $\\int f^-$ are finite."
                },
                {
                    id: 22,
                    category: "Integration",
                    front: "State the basic properties of integration for simple functions.",
                    back: "Let $\\phi, \\psi$ be non-negative simple functions. Then:\\n\\n1. If $c \\geq 0$: $\\int c\\phi = c\\int \\phi$\\n\\n2. $\\int(\\phi+\\psi) = \\int\\phi + \\int \\psi$\\n\\n3. If $\\phi \\leq \\psi$: $\\int \\phi \\leq \\int \\psi$\\n\\n4. The map $A \\mapsto \\int_A d\\mu$ is a measure on $\\Sigma$"
                },
                {
                    id: 23,
                    category: "Integration",
                    front: "State the basic properties of measurable functions.",
                    back: "‚Ä¢ The sum and product of measurable functions are measurable\\n\\n‚Ä¢ If $f: (X, \\Sigma_1) \\to (Y, \\Sigma_2)$ and $g: (Y, \\Sigma_2) \\to (Z, \\Sigma_3)$ are measurable, then $g \\circ f$ is measurable\\n\\n‚Ä¢ The pointwise supremum, infimum, limsup, and liminf of measurable functions are measurable\\n\\n‚Ä¢ The pointwise limit of measurable functions is measurable (when the codomain is a metric space)"
                },
                {
                    id: 24,
                    category: "Integration",
                    front: "State the Simple Function Approximation Theorem.",
                    back: "1. If $f: X \\to [0,\\infty]$ is measurable, there exists a sequence $\\{\\phi_k\\}$ of simple functions such that $0 \\leq \\phi_1 \\leq \\phi_2 \\leq \\cdots \\leq f$, $\\phi_k \\to f$ pointwise, and $\\phi_k \\to f$ uniformly on sets where $f$ is bounded.\\n\\n2. If $f: X \\to \\mathbb{C}$ is measurable, there exists a sequence $\\{\\phi_k\\}$ of simple functions such that $0 \\leq |\\phi_1| \\leq |\\phi_2| \\leq \\cdots \\leq |f|$, $\\phi_k \\to f$ pointwise, and $\\phi_k \\to f$ uniformly on sets where $f$ is bounded."
                },
                {
                    id: 25,
                    category: "Integration",
                    front: "State the Monotone Convergence Theorem.",
                    back: "Let $\\{f_n\\}$ be non-negative measurable functions with $f_1(x) \\leq f_2(x) \\leq \\cdots$ for all $x \\in X$. Then the pointwise limit $f(x) := \\lim f_n(x)$ is measurable and:\\n$$\\lim_{n \\to \\infty} \\int f_n \\, d\\mu = \\int f \\, d\\mu$$"
                },
                {
                    id: 26,
                    category: "Integration",
                    front: "State the Additivity of Integral Theorem.",
                    back: "Let $\\{f_n\\}$ be a sequence of non-negative measurable functions. Then:\\n$$\\int_X \\sum_{n=1}^\\infty f_n \\, d\\mu = \\sum_{n=1}^\\infty \\int_X f_n \\, d\\mu$$"
                },
                {
                    id: 27,
                    category: "Integration",
                    front: "State Fatou's Lemma.",
                    back: "Let $\\{f_n\\}$ be non-negative measurable functions. Then:\\n$$\\int \\liminf_{n \\to \\infty} f_n \\, d\\mu \\leq \\liminf_{n \\to \\infty} \\int f_n \\, d\\mu$$"
                },
                {
                    id: 28,
                    category: "Integration",
                    front: "State the Dominated Convergence Theorem.",
                    back: "Let $\\{f_n\\}$ be measurable functions such that $f_n \\to f$ pointwise a.e., and $\\exists$ integrable $g$ with $|f_n(x)| \\leq g(x)$ a.e. for all $n$. Then $f \\in L^1(\\mu)$ and:\\n$$\\lim_{n \\to \\infty} \\int f_n \\, d\\mu = \\int f \\, d\\mu$$"
                },
                {
                    id: 29,
                    category: "Integration",
                    front: "State the Absolute Convergence Theorem.",
                    back: "Let $\\{f_n\\}$ be a sequence of $L^1$ functions such that $\\sum_{n=1}^\\infty \\int |f_n| < \\infty$. Then $\\sum_{n=1}^\\infty f_n$ converges a.e. to an $L^1$ function, and:\\n$$\\int \\sum_{n=1}^\\infty f_n = \\sum_{n=1}^\\infty \\int f_n$$"
                },
                {
                    id: 30,
                    category: "Integration",
                    front: "State Tonelli's Theorem.",
                    back: "Let $(X, \\Sigma, \\mu)$ and $(Y, \\mathcal{T}, \\nu)$ be $\\sigma$-finite measure spaces. If $f: X \\times Y \\to [0,\\infty]$ is a non-negative measurable function, then the functions:\\n\\n$$g(x) = \\int_Y f_x(y)d\\nu \\text{ and } h(y) = \\int_X f^y(x)d\\mu$$\\n\\n are non-negative measurable functions on $X$ and $Y$ respectively.\\n\\n Moreover,\\n$$\\int_{X \\times Y} f(x,y)d(\\mu \\times \\nu) = \\int_X \\left[\\int_Y f(x,y)d\\nu(y)\\right] d\\mu(x) = \\int_Y \\left[\\int_X f(x,y)d\\mu(x)\\right] d\\nu(y)$$"
                },
                {
                    id: 31,
                    category: "Integration",
                    front: "State Fubini's Theorem.",
                    back: "Let $(X, \\Sigma, \\mu)$ and $(Y, \\mathcal{T}, \\nu)$ be $\\sigma$-finite measure spaces. If $f \\in L^1(\\mu \\times \\nu)$, then:\\n\\n1. $f_x \\in L^1(\\nu)$ for a.e. $x \\in X$\\n\\n2. $f^y \\in L^1(\\mu)$ for a.e. $y \\in Y$\\n\\n3. The iterated integrals equal the double integral"
                },
                
                // Section 3: Signed Measures  
                {
                    id: 32,
                    category: "Signed Measures",
                    front: "Define a signed measure.",
                    back: "A function $\\nu: \\Sigma \\to [-\\infty,\\infty]$ such that:\\n\\n‚Ä¢ $\\nu(\\emptyset) = 0$\\n\\n‚Ä¢ $\\nu$ assumes at most one of the values $\\pm\\infty$\\n\\n‚Ä¢ **Countable additivity**: If $\\{A_k\\}$ are disjoint sets in $\\Sigma$, then $\\nu\\left(\\bigcup_{k=1}^\\infty A_k\\right) = \\sum_{k=1}^\\infty \\nu(A_k)$"
                },
                {
                    id: 33,
                    category: "Signed Measures",
                    front: "Define mutual singularity.",
                    back: "Two signed measures $\\mu$ and $\\nu$ on $(X, \\Sigma)$ are **mutually singular** (written $\\mu \\perp \\nu$) if there exist $A, B \\in \\Sigma$ such that:\\n\\n‚Ä¢ $A \\cap B = \\emptyset$ and $A \\cup B = X$\\n\\n‚Ä¢ $\\mu(A) = 0$ and $\\nu(B) = 0$\\n\\n Mutual singularity means $\\mu$ and $\\nu$ \"live on disjoint sets\"."
                },
                {
                    id: 34,
                    category: "Signed Measures",
                    front: "Define total variation.",
                    back: "Given a Jordan decomposition $\\nu = \\nu^+ - \\nu^-$, the **total variation** of $\\nu$ is the measure:\\n$$|\\nu| = \\nu^+ + \\nu^-$$"
                },
                {
                    id: 35,
                    category: "Signed Measures",
                    front: "Define absolute continuity of measures.",
                    back: "Let $\\nu$ be a signed measure and $\\mu$ be a positive measure on $(X, \\Sigma)$. We say $\\nu$ is **absolutely continuous** with respect to $\\mu$ (written $\\nu \\ll \\mu$) if:\\n$$\\nu(E) = 0 \\text{ for every } E \\in \\Sigma \\text{ with } \\mu(E) = 0$$"
                },
                {
                    id: 36,
                    category: "Signed Measures",
                    front: "Define a signed measure defined by a function.",
                    back: "Let $f: X \\to [-\\infty, \\infty]$ be an extended $\\mu$-integrable function. The **signed measure $\\nu$ defined by $f$** is:\\n$$\\nu(A) = \\int_A f \\, d\\mu$$\\n In this situation, we write $d\\nu = f \\, d\\mu$."
                },
                {
                    id: 37,
                    category: "Signed Measures",
                    front: "State the Hahn Decomposition Theorem.",
                    back: "If $\\nu$ is a signed measure on $(X,\\Sigma)$, there exist disjoint measurable sets $P$ and $N$ such that:\\n\\n‚Ä¢ $\\nu \\geq 0$ on $P$\\n\\n‚Ä¢ $\\nu \\leq 0$ on $N$\\n\\n‚Ä¢ $X = P \\cup N$"
                },
                {
                    id: 38,
                    category: "Signed Measures",
                    front: "State the Jordan Decomposition Theorem.",
                    back: "If $\\nu$ is a signed measure on $(X, \\Sigma)$, there exist unique positive measures $\\nu^+$ and $\\nu^-$ such that:\\n\\n‚Ä¢ $\\nu = \\nu^+ - \\nu^-$\\n\\n‚Ä¢ $\\nu^+ \\perp \\nu^-$ (mutually singular)\\n\\n The measures $\\nu^+$ and $\\nu^-$ are called the **positive and negative variations** of $\\nu$."
                },
                {
                    id: 39,
                    category: "Signed Measures",
                    front: "State the Lebesgue-Radon-Nikodym Theorem.",
                    back: "Let $\\nu$ be a $\\sigma$-finite signed measure and $\\mu$ be a $\\sigma$-finite positive measure on $(X,\\Sigma)$. There exist unique $\\sigma$-finite signed measures $\\nu_{ac}$ and $\\nu_s$ such that:\\n\\n‚Ä¢ $\\nu_s \\perp \\mu$, $\\nu_{ac} \\ll \\mu$, and $\\nu = \\nu_{ac} + \\nu_s$\\n\\n‚Ä¢ $\\exists$ extended $\\mu$-integrable function $f: X \\to \\mathbb{R}$ such that $\\nu_{ac}(A) = \\int_A f d\\mu$, and any two such functions are equal $\\mu$-a.e.\\n\\n The decomposition $\\nu = \\nu_{ac} + \\nu_s$ is called the **Lebesgue decomposition** of $\\nu$ with respect to $\\mu$.\\n\\n In the case where $\\nu \\ll \\mu$, we have that $d\\nu = f d\\mu$ for some $f$, and we call $f$ the **Radon-Nikodym derivative** of $\\nu$ with respect to $\\mu$. We denote it by $d\\nu/d\\mu$: $d\\nu = \\frac{d\\nu}{d\\mu} d\\mu$."
                },
                {
                    id: 40,
                    category: "Signed Measures",
                    front: "State basic facts about absolute continuity.",
                    back: "‚Ä¢ $\\nu \\ll \\mu \\Leftrightarrow |\\nu| \\ll \\mu \\Leftrightarrow \\nu^+ \\ll \\mu$ and $\\nu^- \\ll \\mu$\\n\\n‚Ä¢ If $\\nu \\perp \\mu$ and $\\nu \\ll \\mu$, then $\\nu \\equiv 0$\\n\\n‚Ä¢ For finite signed measure $\\nu$ and positive measure $\\mu$:\\n$\\nu \\ll \\mu \\Leftrightarrow$ for all $\\epsilon >0$, $\\exists \\delta>0$ s.t. $|\\nu(A)| < \\epsilon$ whenever $\\mu(A)< \\delta$"
                },
                {
                    id: 41,
                    category: "Signed Measures",
                    front: "State the Radon-Nikodym Chain Rule.",
                    back: "Suppose that $\\nu$ is a $\\sigma$-finite signed measure, and $\\mu, \\lambda$ are $\\sigma$-finite measures on $(X,\\Sigma)$ such that $\\nu \\ll \\mu$ and $\\mu \\ll \\lambda$. Then:\\n\\n‚Ä¢ If $g \\in L^1(\\nu)$, then $g(d\\nu/d\\mu) \\in L^1(\\mu)$, and:\\n$$\\int g d\\nu = \\int g \\frac{d\\nu}{d\\mu} d\\mu$$\\n\\n‚Ä¢ We have $\\nu \\ll \\lambda$, and:\\n$$\\frac{d\\nu}{d\\lambda} = \\frac{d\\nu}{d\\mu} \\frac{d\\mu}{d\\lambda} \\quad \\lambda\\text{-a.e.}$$"
                },
                
                // Section 4: Functional Analysis
                {
                    id: 42,
                    category: "Functional Analysis",
                    front: "Define a norm on a vector space $V$.",
                    back: "A function $\\|\\cdot\\|: V \\to [0,\\infty)$ such that:\\n\\n‚Ä¢ **Triangle inequality**: $\\|x + y\\| \\leq \\|x\\| + \\|y\\|$\\n\\n‚Ä¢ **Homogeneity**: $\\|\\lambda x\\| = |\\lambda|\\|x\\|$ for all $\\lambda \\in \\mathbb{K}$\\n\\n‚Ä¢ **Positive definiteness**: $\\|x\\| = 0 \\Leftrightarrow x = 0$"
                },
                {
                    id: 43,
                    category: "Functional Analysis",
                    front: "Define a Banach space.",
                    back: "A normed vector space that is complete with respect to the norm metric (every Cauchy sequence converges)."
                },
                {
                    id: 44,
                    category: "Functional Analysis",
                    front: "Define equivalent norms.",
                    back: "Two norms $\\|\\cdot\\|_1$ and $\\|\\cdot\\|_2$ on $V$ are **equivalent** if there exist $C_1, C_2 > 0$ such that:\\n$$C_1 \\|x\\|_1 \\leq \\|x\\|_2 \\leq C_2 \\|x\\|_1$$\\n for all $x \\in V$."
                },
                {
                    id: 45,
                    category: "Functional Analysis",
                    front: "Define absolute convergence of series.",
                    back: "A series $\\sum_{n=1}^\\infty x_n$ in a normed space $V$ is **absolutely convergent** if:\\n$$\\sum_{n=1}^\\infty \\|x_n\\| < \\infty$$"
                },
                {
                    id: 46,
                    category: "Functional Analysis",
                    front: "Define a bounded linear map.",
                    back: "A linear map $T: V \\to W$ between normed vector spaces is **bounded** if there exists $C \\geq 0$ such that:\\n$$\\|T(x)\\| \\leq C \\|x\\|$$\\n for all $x \\in V$."
                },
                {
                    id: 47,
                    category: "Functional Analysis",
                    front: "Define the operator norm.",
                    back: "For $T \\in L(V, W)$, the **operator norm** is:\\n$$\\|T\\| = \\sup \\{\\|T(x)\\| : \\|x\\|=1\\} = \\sup \\left\\{ \\frac{\\|T(x)\\|}{\\|x\\|} : x\\neq 0 \\right\\}$$"
                },
                {
                    id: 48,
                    category: "Functional Analysis",
                    front: "Let $T \\in L(V, W)$. What does it mean to say that $T$ is an isomorphism or an isometry?.",
                    back: "$T$ is an **isomorphism** if $T$ is bijective and $T^{-1}$ is bounded\\n\\n‚Ä¢ $T$ is an **isometry** if $\\|T(x)\\| = \\|x\\|$ for all $x \\in V$\\n\\n An isometry is injective and is an isomorphism onto its image."
                },
                {
                    id: 49,
                    category: "Functional Analysis",
                    front: "Define the dual space.",
                    back: "If $V$ is a normed vector space, the **dual space** $V^* = L(V, \\mathbb{K})$ is the space of bounded linear functionals on $V$."
                },
                {
                    id: 50,
                    category: "Functional Analysis",
                    front: "Define a sublinear functional.",
                    back: "On a real vector space $V$, a **sublinear functional** is a map $p: V \\to \\mathbb{R}$ such that:\\n\\n‚Ä¢ $p(x+y) \\leq p(x) + p(y)$\\n\\n‚Ä¢ $p(\\lambda x) = \\lambda p(x)$ for all $\\lambda \\geq 0$"
                },
                {
                    id: 51,
                    category: "Functional Analysis",
                    front: "Define reflexivity of a Banach space $V$.",
                    back: "A Banach space $V$ is **reflexive** if the natural embedding $V \\to V^{**}$ given by $x \\mapsto \\hat{x}$ (where $\\hat{x}(f) = f(x)$) is surjective.\\n\\n Equivalently, $V = \\overline{\\widehat{V}}$ where $\\widehat{V}$ is the image of $V$ in $V^{**}$."
                },
                {
                    id: 52,
                    category: "Functional Analysis",
                    front: "Define an inner product on a complex vector space.",
                    back: "A map $\\langle\\cdot,\\cdot\\rangle: H \\times H \\to \\mathbb{C}$ such that:\\n\\n1. $\\langle ax + by, z\\rangle = a\\langle x,z\\rangle + b\\langle y,z\\rangle$ (linearity in first argument)\\n\\n2. $\\langle y,x\\rangle = \\overline{\\langle x,y\\rangle}$ (conjugate symmetry)\\n\\n3. $\\langle x,x\\rangle \\in (0,\\infty)$ for nonzero $x$ (positive definiteness)"
                },
                {
                    id: 53,
                    category: "Functional Analysis",
                    front: "Define a Hilbert space.",
                    back: "A pre-Hilbert space (complex vector space with inner product) that is complete with respect to the induced norm $\\|x\\| := \\sqrt{\\langle x,x\\rangle}$."
                },
                {
                    id: 54,
                    category: "Functional Analysis",
                    front: "Define orthogonality and orthonormal sets.",
                    back: "In a Hilbert space $H$, we say $x \\perp y$ if $\\langle x, y\\rangle = 0$.\\n\\n For $E \\subset H$, define $E^\\perp = \\{x \\in H : \\langle x, y\\rangle = 0, \\forall y \\in E\\}$.\\n\\n A subset $\\{x_\\alpha\\}$ is **orthonormal** if:\\n\\n‚Ä¢ $\\|x_\\alpha\\| = 1$ for all $\\alpha$\\n\\n‚Ä¢ $x_\\alpha \\perp x_\\beta$ whenever $\\alpha \\neq \\beta$"
                },
                {
                    id: 55,
                    category: "Functional Analysis",
                    front: "Define a unitary map.",
                    back: "A **unitary map** from Hilbert space $H_1$ to $H_2$ is an invertible linear map $U: H_1 \\to H_2$ that preserves inner products:\\n$$\\langle U(x), U(y)\\rangle_2 = \\langle x, y\\rangle_1$$\\n for all $x,y \\in H_1$."
                },
                {
                    id: 56,
                    category: "Functional Analysis",
                    front: "State the completeness characterization for Banach spaces.",
                    back: "A normed vector space $V$ is complete $\\Leftrightarrow$ every absolutely convergent series in $V$ converges."
                },
                {
                    id: 57,
                    category: "Functional Analysis",
                    front: "State the continuity characterization for linear maps.",
                    back: "For a linear map $T: V \\to W$ between normed spaces, TFAE:\\n\\n1. $T$ is continuous\\n\\n2. $T$ is bounded"
                },
                {
                    id: 58,
                    category: "Functional Analysis",
                    front: "State the Hahn-Banach Theorem.",
                    back: "Let $V$ be a real vector space, $p$ a sublinear functional, $U \\subset V$ a subspace, and $f: U \\to \\mathbb{R}$ linear with $f(x) \\leq p(x)$ on $U$. Then $\\exists$ linear $F: V \\to \\mathbb{R}$ such that:\\n\\n‚Ä¢ $F|_U = f$ (extends $f$)\\n\\n‚Ä¢ $F(x) \\leq p(x)$ on $V$"
                },
                {
                    id: 59,
                    category: "Functional Analysis",
                    front: "State key applications of the Hahn-Banach Theorem.",
                    back: "Let $V$ be a normed vector space. Then:\\n\\n1. If $U \\subseteq V$ is a closed subspace and $x \\in V - U$, $\\exists f \\in V^*$ such that $f(x) \\neq 0$ and $f|_U = 0$\\n\\n2. If $x \\neq 0$, $\\exists f \\in V^*$ such that $\\|f\\|=1$ and $f(x) = \\|x\\|$\\n\\n3. Bounded linear functionals separate points\\n\\n4. The map $x \\mapsto \\hat{x}$ is a linear isometry from $V$ into $V^{**}$"
                },
                {
                    id: 60,
                    category: "Functional Analysis",
                    front: "State the Baire Category Theorem.",
                    back: "Let $X$ be a complete metric space. Then:\\n\\n1. If $\\{U_n\\}$ is a sequence of open dense subsets, then $\\bigcap_{n=1}^\\infty U_n$ is dense\\n\\n2. $X$ is not a countable union of nowhere dense sets"
                },
                {
                    id: 61,
                    category: "Functional Analysis",
                    front: "State the Open Mapping Theorem.",
                    back: "Let $V$ and $W$ be Banach spaces. If $T \\in L(V, W)$ is surjective, then $T$ is open (maps open sets to open sets)."
                },
                {
                    id: 62,
                    category: "Functional Analysis",
                    front: "State the Closed Graph Theorem.",
                    back: "If $V$ and $W$ are Banach spaces, then $T: V \\to W$ is a closed linear map (i.e., $\\Gamma(T)$ is closed in $V \\times W$) $\\Leftrightarrow T$ is bounded."
                },
                {
                    id: 63,
                    category: "Functional Analysis",
                    front: "State the Uniform Boundedness Principle.",
                    back: "Let $V, W$ be normed spaces with $V$ Banach, and $\\mathcal{A} \\subset L(V,W)$.\\n\\n**If** $\\sup_{T \\in \\mathcal{A}} \\|T(x)\\| < \\infty$ for all $x \\in V$,\\n**then** $\\sup_{T \\in \\mathcal{A}} \\|T\\| < \\infty$.\\n\\n(Pointwise boundedness implies uniform boundedness)"
                },
                {
                    id: 64,
                    category: "Functional Analysis",
                    front: "State the Cauchy-Schwarz Inequality.",
                    back: "In a pre-Hilbert space: $|\\langle x,y\\rangle| \\leq \\|x\\|\\|y\\|$ for all $x,y \\in H$.\\n\\n**Equality** holds $\\Leftrightarrow$ $x$ and $y$ are linearly dependent."
                },
                {
                    id: 65,
                    category: "Functional Analysis",
                    front: "State the Parallelogram Law.",
                    back: "In a Hilbert space $H$, for all $x,y \\in H$:\\n$$\\|x+y\\|^2+ \\|x-y\\|^2 = 2(\\|x\\|^2+\\|y\\|^2)$$"
                },
                {
                    id: 66,
                    category: "Functional Analysis",
                    front: "State the Orthogonal Decomposition Theorem.",
                    back: "Let $H$ be a Hilbert space and $A \\subset H$ be a closed subspace. Then $H = A \\oplus A^\\perp$.\\n\\n That is, each $x \\in H$ can be expressed uniquely as $x = y + z$ where $y \\in A$ and $z \\in A^\\perp$."
                },
                {
                    id: 67,
                    category: "Functional Analysis",
                    front: "State the Riesz Representation Theorem for Hilbert spaces.",
                    back: "Let $H$ be a Hilbert space and $y \\in H$. Then:\\n\\n‚Ä¢ $f_y(x) := \\langle x,y\\rangle$ is a bounded linear functional with $\\|f_y\\| = \\|y\\|$\\n\\n‚Ä¢ The map $\\phi: H \\to H^*$ given by $y \\mapsto f_y$ is a conjugate-linear isometry\\n\\n‚Ä¢ $\\phi$ is surjective"
                },
                {
                    id: 68,
                    category: "Functional Analysis",
                    front: "State Bessel's inequality.",
                    back: "If $\\{x_\\alpha\\}$ is an orthonormal set in a Hilbert space $H$, then for any $y \\in H$:\\n$$\\sum_\\alpha |\\langle y, x_\\alpha \\rangle|^2 \\leq \\|y\\|^2$$\\n\\n In particular, $\\{\\alpha : \\langle y, x_\\alpha \\rangle \\neq 0\\}$ is at most countable."
                },
                {
                    id: 69,
                    category: "Functional Analysis",
                    front: "State the characterization of orthonormal bases for a Hilbert space.",
                    back: "For an orthonormal set $\\{x_\\alpha\\}$ in $H$, TFAE:\\n\\n1. **Completeness**: If $\\langle y, x_\\alpha \\rangle = 0$ for all $\\alpha$, then $y = 0$\\n\\n2. **Parseval's Identity**: $\\|y\\|^2 = \\sum_\\alpha |\\langle y, x_\\alpha \\rangle|^2$ for all $y \\in H$\\n\\n3. **Fourier expansion**: For each $y \\in H$, $y = \\sum_\\alpha \\langle y, x_\\alpha \\rangle x_\\alpha$ (convergent in norm)"
                },
                {
                    id: 70,
                    category: "Functional Analysis",
                    front: "Define the product norm on $V \\times W$.",
                    back: "If $V$ and $W$ are normed vector spaces, then $V \\times W$ is a normed vector space under the **product norm**:\\n$$\\|(x,y)\\| := \\max(\\|x\\|, \\|y\\|)$$\\n for $(x,y) \\in V \\times W$."
                },
                {
                    id: 71,
                    category: "Functional Analysis",
                    front: "Define the quotient norm on $V/U$.",
                    back: "If $U \\subset V$ is a closed vector subspace of a normed vector space, then $V/U$ is a normed vector space under the **quotient norm**:\\n$$\\|x + U\\| := \\inf_{u \\in U} \\|x + u\\|$$\\n for $x + U \\in V/U$."
                },
                {
                    id: 72,
                    category: "Functional Analysis",
                    front: "State the proposition about existence of orthonormal bases.",
                    back: "**Proposition**: Every Hilbert space has an orthonormal basis."
                },
                {
                    id: 73,
                    category: "Functional Analysis", 
                    front: "When is a Hilbert space $H$ separable?",
                    back: "**Proposition**: A Hilbert space $H$ is separable (i.e. has a countable dense subset) $\\Leftrightarrow$ $H$ has a countable orthonormal basis."
                },
                
                // Section 5: Lp Spaces
                {
                    id: 74,
                    category: "Lp Spaces",
                    front: "Define $\\|f\\|_p$ for $0 < p < \\infty$.",
                    back: "$\\|f\\|_p := \\left(\\int_X |f|^p \\, d\\mu\\right)^{1/p}$\\n\\n Note: May equal $\\infty$. Define $L^p(X, \\Sigma, \\mu) := \\{f : X \\to \\mathbb{C} \\text{ measurable} : \\|f\\|_p < \\infty\\}$"
                },
                {
                    id: 75,
                    category: "Lp Spaces",
                    front: "Define the essential supremum $\\|f\\|_\\infty$.",
                    back: "$\\|f\\|_\\infty := \\inf\\{a \\geq 0 : \\mu(\\{x : |f(x)| > a\\}) = 0\\}$\\n\\n with convention $\\inf \\emptyset = \\infty$. This is the **essential supremum** of $|f|$.\\n\\n Define $L^\\infty(X) := \\{f \\text{ measurable} : \\|f\\|_\\infty < \\infty\\}$."
                },
                {
                    id: 76,
                    category: "Lp Spaces",
                    front: "For what values of $p$ is $L^p(X)$ a normed vector space?",
                    back: "$L^p(X)$ is a normed vector space under $\\|\\cdot\\|_p \\Leftrightarrow p \\geq 1$.\\n\\n For $0 < p < 1$, the triangle inequality fails, so $\\|\\cdot\\|_p$ is not a norm."
                },
                {
                    id: 77,
                    category: "Lp Spaces",
                    front: "State H√∂lder's Inequality.",
                    back: "Let $1 < p < \\infty$ and $1/p + 1/q = 1$ (so $q = \\frac{p}{p-1}$ is the conjugate exponent). For measurable $f,g$:\\n$$\\|fg\\|_1 \\leq \\|f\\|_p\\|g\\|_q$$\\n If $f \\in L^p$ and $g \\in L^q$, then $fg \\in L^1$.\\n\\n**Equality** holds $\\Leftrightarrow$ $\\exists \\lambda \\geq 0$ such that $|f(x)|^p = \\lambda |g(x)|^q$ a.e."
                },
                {
                    id: 78,
                    category: "Lp Spaces",
                    front: "State Minkowski's Inequality.",
                    back: "For $1 \\leq p < \\infty$ and $f,g \\in L^p$:\\n$$\\|f + g\\|_p \\leq \\|f\\|_p + \\|g\\|_p$$\\n This is the triangle inequality in $L^p$, showing $L^p$ is a normed space for $p \\geq 1$."
                },
                {
                    id: 79,
                    category: "Lp Spaces",
                    front: "State the completeness theorem for $L^p$ spaces.",
                    back: "For $1 \\leq p < \\infty$, $L^p$ is a Banach space.\\n\\n**Proof idea**: Show that if $\\sum_{k=1}^\\infty \\|f_k\\|_p < \\infty$, then $\\sum f_k$ converges in $L^p$ norm."
                },
                {
                    id: 80,
                    category: "Lp Spaces",
                    front: "State the density of simple functions in $L^p$.",
                    back: "For $1 \\leq p < \\infty$, the set of simple functions $f = \\sum_{n=1}^\\infty a_n \\mathbf{1}_{A_n}$ where $\\mu(A_n) < \\infty$ for all $n$ is dense in $L^p$."
                },
                {
                    id: 81,
                    category: "Lp Spaces",
                    front: "State key properties of $L^\\infty$.",
                    back: "1. If $f \\in L^1$ and $g \\in L^\\infty$: $\\|fg\\|_1 \\leq \\|f\\|_1\\|g\\|_\\infty$\\n\\n2. $\\|\\cdot\\|_\\infty$ is a norm on $L^\\infty$\\n\\n3. $\\|f_n-f\\|_\\infty \\to 0 \\Leftrightarrow \\exists E$ with $\\mu(E^c)=0$ and $f_n \\to f$ uniformly on $E$\\n\\n4. $L^\\infty$ is a Banach space\\n\\n5. Simple functions are dense in $L^\\infty$"
                },
                {
                    id: 82,
                    category: "Lp Spaces",
                    front: "State the duality theorem for $L^p$ spaces.",
                    back: "For $1 < p < \\infty$, $(L^p)^* \\cong L^q$ where $1/p + 1/q = 1$.\\n\\n Each $g \\in L^q$ defines $\\phi_g \\in (L^p)^*$ by $\\phi_g(f) := \\int fg \\, d\\mu$, and every element of $(L^p)^*$ arises this way.\\n\\n**Special case**: When $\\mu$ is **$\\sigma$-finite**, $(L^1)^* \\cong L^\\infty$. Each $g \\in L^\\infty$ defines $\\phi_g \\in (L^1)^*$ by $\\phi_g(f) := \\int fg \\, d\\mu$, and every element of $(L^1)^*$ arises this way."
                },
                {
                    id: 83,
                    category: "Lp Spaces",
                    front: "State the interpolation property of $L^p$ spaces.",
                    back: "If $0 < p < q < r \\leq \\infty$, then $L^q \\subset L^p + L^r$.\\n\\n That is, each $f \\in L^q$ is the sum of a function in $L^p$ and a function in $L^r$."
                },
                {
                    id: 84,
                    category: "Lp Spaces",
                    front: "Give an example showing $L^p \\not\\subset L^q$ and $L^q \\not\\subset L^p$ for $p \\neq q$.",
                    back: "On $(0,\\infty)$ with Lebesgue measure, consider $f_a(x) = x^{-a}$ for $a > 0$.\\n\\n**$L^p \\not\\subset L^q$ when $p < q$**: Take $f(x) = x^{-1/q} \\chi_{(0,1)}(x)$\\n‚Ä¢ $\\|f\\|_p^p = \\int_0^1 x^{-p/q} dx < \\infty$ (since $p/q < 1$)\\n‚Ä¢ $\\|f\\|_q^q = \\int_0^1 x^{-1} dx = \\infty$"
                },
                {
                    id: 85,
                    category: "Lp Spaces",
                    front: "What is the geometric interpretation of $L^2$ spaces?",
                    back: "$L^2$ is a Hilbert space with inner product $\\langle f,g\\rangle := \\int fg \\, d\\mu$.\\n\\n This means:\\n‚Ä¢ Cauchy-Schwarz: $|\\langle f,g\\rangle| \\leq \\|f\\|_2 \\|g\\|_2$\\n‚Ä¢ Parallelogram law: $\\|f+g\\|_2^2 + \\|f-g\\|_2^2 = 2(\\|f\\|_2^2 + \\|g\\|_2^2)$\\n‚Ä¢ Riesz representation: $(L^2)^* \\cong L^2$"
                },
                {
                    id: 86,
                    category: "Lp Spaces",
                    front: "State the conjugate exponent relationship.",
                    back: "For $1 < p < \\infty$, the **conjugate exponent** $q$ is defined by $\\frac{1}{p} + \\frac{1}{q} = 1$.\\n\\n Explicitly: $q = \\frac{p}{p-1}$.\\n\\n**Special cases**:\\n‚Ä¢ $p = 2 \\Rightarrow q = 2$ (self-dual)\\n‚Ä¢ $p \\to 1^+ \\Rightarrow q \\to \\infty$\\n‚Ä¢ $p \\to \\infty \\Rightarrow q \\to 1^+$"
                },
                {
                    id: 87,
                    category: "Lp Spaces",
                    front: "Give an example showing $(L^\\infty)^* \\supsetneq L^1$.",
                    back: "On $X = [0, 1]$ with Lebesgue measure, define $T: L^\\infty \\to \\mathbb{C}$ by $T(f) = f(0)$.\\n\\n This is a bounded linear functional on $L^\\infty$ that **cannot be represented** as integration against any $L^1$ function, since it uses information on a measure-zero set.\\n\\n Thus $(L^\\infty)^*$ properly contains $L^1$."
                },
                
                // Section 6: Haar and Radon Measures
                {
                    id: 88,
                    category: "Haar and Radon Measures",
                    front: "State the Riesz Representation Theorem for Radon measures.",
                    back: "If $X$ is a locally compact Hausdorff space, then every positive linear functional on $C_c(X)$ (continuous functions with compact support) is integration against a unique Radon measure."
                },
                {
                    id: 89,
                    category: "Haar and Radon Measures",
                    front: "State the existence theorem for Haar measure.",
                    back: "Every locally compact group admits a left-invariant Haar measure.\\n\\n That is, if $G$ is a locally compact group, then there exists a Radon measure $\\mu$ on $G$ such that $\\mu(gA) = \\mu(A)$ for all $g \\in G$ and measurable $A$."
                },
                {
                    id: 90,
                    category: "Haar and Radon Measures",
                    front: "State the uniqueness theorem for Haar measure.",
                    back: "The Haar measure is unique up to scaling.\\n\\n That is, if $\\mu$ and $\\nu$ are both left-invariant Haar measures on a locally compact group $G$, then there exists a constant $c > 0$ such that $\\nu = c\\mu$."
                },
                {
                    id: 91,
                    category: "Haar and Radon Measures",
                    front: "When is Haar measure both left- and right-invariant?",
                    back: "For **abelian groups** or **compact groups**, Haar measure is both left- and right-invariant.\\n\\n**Examples**:\\n‚Ä¢ $\\mathbb{R}^n$ with addition (abelian): Lebesgue measure\\n‚Ä¢ $S^1$ with multiplication (compact abelian): arc length measure\\n‚Ä¢ $SO(n)$ (compact): normalized Haar measure"
                },
                {
                    id: 114,
                    category: "Haar and Radon Measures",
                    front: "Define a positive linear functional on $C_c(X)$.",
                    back: "Let $X$ be a locally compact Hausdorff (LCH) space, and $C_c(X) = \\{f: X \\to \\mathbb{R} : f \\text{ is continuous and has compact support}\\}$.\\n\\n A linear functional $I: C_c(X) \\to \\mathbb{R}$ is called **positive** if $I(f) \\geq 0$ whenever $f \\geq 0$."
                },
                {
                    id: 115,
                    category: "Haar and Radon Measures",
                    front: "State the key property of positive linear functionals on $C_c(X)$.",
                    back: "**Proposition**: Positive linear functionals are strongly continuous.\\n\\n If $I$ is a positive linear functional on $C_c(X)$, then for each compact $K \\subset X$, there exists a constant $C_K$ such that:\\n$$|I(f)| \\leq C_K \\|f\\|_u$$\\n for all $f \\in C_c(X)$ with $\\operatorname{supp}(f) \\subset K$."
                },
                {
                    id: 116,
                    category: "Haar and Radon Measures",
                    front: "State the detailed Riesz Representation Theorem for Radon measures.",
                    back: "**Riesz Representation Theorem**: If $X$ is a locally compact Hausdorff space, then every positive linear functional $I$ on $C_c(X)$ corresponds to a unique Radon measure $\\mu$ such that:\\n$$I(f) = \\int_X f \\, d\\mu$$\\n for all $f \\in C_c(X)$.\\n\\n Moreover, this establishes a bijection between positive linear functionals on $C_c(X)$ and Radon measures on $X$."
                },
                {
                    id: 117,
                    category: "Haar and Radon Measures",
                    front: "State the detailed existence and uniqueness theorems for Haar measure.",
                    back: "**Existence**: Every locally compact group $G$ admits a left-invariant Haar measure $\\mu$ such that $\\mu(gA) = \\mu(A)$ for all $g \\in G$ and measurable $A$.\\n\\n**Uniqueness**: The Haar measure is unique up to scaling. If $\\mu$ and $\\nu$ are both left-invariant Haar measures on $G$, then $\\exists c > 0$ such that $\\nu = c\\mu$.\\n\\n**Bi-invariance**: For abelian or compact groups, Haar measure is both left- and right-invariant."
                },
                {
                    id: 118,
                    category: "Haar and Radon Measures",
                    front: "Define outer regular, inner regular, and regular measures.",
                    back: "Let $(X, \\mathcal{B}, \\mu)$ be an LCH measure space with Borel $\\sigma$-algebra. For $E \\in \\mathcal{B}$:\\n\\n‚Ä¢ $\\mu$ is **outer regular** on $E$ if:\\n$$\\mu(E) = \\inf\\{\\mu(U) : U \\supset E, U \\text{ open}\\}$$\\n\\n‚Ä¢ $\\mu$ is **inner regular** on $E$ if:\\n$$\\mu(E) = \\sup\\{\\mu(K) : K \\subset E, K \\text{ compact}\\}$$\\n\\n‚Ä¢ $\\mu$ is **regular** if it is both outer and inner regular on all Borel sets."
                },
                {
                    id: 119,
                    category: "Haar and Radon Measures", 
                    front: "Define a Radon measure.",
                    back: "A **Radon measure** on a locally compact Hausdorff space $X$ is a Borel measure that is:\\n\\n‚Ä¢ **Finite on compact sets**: $\\mu(K) < \\infty$ for all compact $K \\subset X$\\n\\n‚Ä¢ **Outer regular on all Borel sets**: For every $E \\in \\mathcal{B}_X$, $\\mu(E) = \\inf\\{\\mu(U) : U \\supset E, U \\text{ open}\\}$\\n\\n‚Ä¢ **Inner regular on all open sets**: For every open $U \\subset X$, $\\mu(U) = \\sup\\{\\mu(K) : K \\subset U, K \\text{ compact}\\}$"
                },
                
                // Complex Measures
                {
                    id: 92,
                    category: "Complex Measures",
                    front: "Define a complex measure.",
                    back: "A **complex measure** on a measurable space $(X, \\Sigma)$ is a map $\\nu: \\Sigma \\to \\mathbb{C}$ such that:\\n\\n‚Ä¢ $\\nu(\\emptyset) = 0$\\n\\n‚Ä¢ If $\\{E_j\\}$ is a sequence of disjoint sets in $\\Sigma$, then $\\nu\\left( \\bigcup_{j=1}^\\infty E_j\\right) = \\sum_{j=1}^\\infty \\nu(E_j)$\\n\\n**Note**: Infinite values are not allowed, so a positive measure is a complex measure $\\Leftrightarrow$ it is finite.\\n\\nIf $\\nu$ is a complex measure, we write $\\nu = \\nu_r + i \\nu_i$ for the real and imaginary parts."
                },
                {
                    id: 93,
                    category: "Complex Measures",
                    front: "State the Lebesgue-Radon-Nikodym theorem for complex measures.",
                    back: "If $\\nu: \\Sigma \\to \\mathbb{C}$ is a complex measure and $\\mu$ is a $\\sigma$-finite positive measure on $(X, \\Sigma)$, then there exists a complex measure $\\lambda$ and $f \\in L^1(\\mu)$ such that:\\n\\n‚Ä¢ $\\lambda \\perp \\mu$ (mutually singular)\\n\\n‚Ä¢ $d\\nu = d\\lambda + f \\, d\\mu$\\n\\nMoreover, these are **unique**. If $\\lambda' \\perp \\mu$ and $d\\nu = d\\lambda' + f' \\, d\\mu$, then $\\lambda = \\lambda'$ and $f = f'$ $\\mu$-a.e."
                },
                {
                    id: 94,
                    category: "Complex Measures",
                    front: "Define the total variation of a complex measure.",
                    back: "The **total variation** of a complex measure $\\mu\\colon \\Sigma \\rightarrow \\mathbb{C}$ can be defined in two equivalent ways:\\n\\n**Definition 1** (Radon-Nikodym): The positive measure $|\\mu|$ determined by the property that if $f = \\frac{d\\mu}{d\\nu}$ where $\\nu$ is a positive measure, then $|f| = \\frac{d|\\mu|}{d\\nu}$.\\n\\n**Definition 2** (Supremum): $$|\\mu|(E)\\defeq \\sup \\left\\{ \\sum_{i=1}^\\infty |\\mu(E_i)| \\colon \\{E_i\\} \\; \\text{is a countable partition of } E\\right\\}$$\\n\\n**Properties**:\\n\\n‚Ä¢ $|\\mu|$ is the **smallest positive measure** such that $|\\mu(E)|\\leq |\\mu| (E), \\forall E\\in \\Sigma$\\n\\n‚Ä¢ If $\\mu$ is finite, then $|\\mu|$ is finite with $|\\mu|(X) = \\sup \\left\\{ \\sum_{i=1}^\\infty |\\mu(E_i)| \\colon \\{E_i\\} \\; \\text{is a countable partition of } X\\right\\}$"
                },
                {
                    id: 95,
                    category: "Complex Measures",
                    front: "State the basic properties of complex measure total variation.",
                    back: "Let $\\nu$ be a complex measure on $(X, \\Sigma)$. Then:\\n\\n1. $|\\nu(E)| \\leq |\\nu|(E)$ for all $E \\in \\Sigma$\\n\\n2. $\\nu \\ll |\\nu|$, and $d\\nu/d|\\nu|$ has absolute value $1$ $|\\nu|$-a.e.\\n\\n3. $L^1(\\nu) = L^1(|\\nu|)$ and if $f \\in L^1(\\nu)$, then $\\left|\\int f \\, d\\nu\\right| \\leq \\int |f| \\, d|\\nu|$\\n\\n4. If $\\nu_1$ and $\\nu_2$ are complex measures, then $|\\nu_1 + \\nu_2| \\leq |\\nu_1| + |\\nu_2|$"
                },

                // Additional Signed Measures - Convex Functions
                {
                    id: 96,
                    category: "Signed Measures",
                    front: "Define a convex function.",
                    back: "A function $F: (a,b) \\to \\mathbb{R}$ is called **convex** if:\\n$$F(\\lambda s + (1-\\lambda)t) \\leq \\lambda F(s) + (1-\\lambda) F(t)$$\\nfor all $s,t \\in (a,b)$ and $\\lambda \\in (0,1)$.\\n\\n**Geometric interpretation**: The graph of $F$ over the interval from $s$ to $t$ lies underneath the line segment joining $(s, F(s))$ to $(t, F(t))$."
                },
                {
                    id: 97,
                    category: "Signed Measures",
                    front: "State Jensen's Inequality.",
                    back: "If $(X, \\Sigma, \\mu)$ is a measure space with $\\mu(X) = 1$, $g: X \\to (a,b)$ is in $L^1(\\mu)$, and $F$ is convex on $(a,b)$, then:\\n$$F\\left( \\int_X g \\, d\\mu\\right) \\leq \\int_X F \\circ g \\, d\\mu$$\\n\\n This generalizes the discrete Jensen's inequality to the continuous setting using integration."
                },
                {
                    id: 98,
                    category: "Signed Measures",
                    front: "State key properties of convex functions.",
                    back: "For a function $F: (a,b) \\to \\mathbb{R}$:\\n\\n‚Ä¢ $F$ is convex $\\Leftrightarrow$ for all $s \\leq s' < t \\leq t'$ in $(a,b)$:\\n$$\\frac{F(t)-F(s)}{t-s} \\leq \\frac{F(t')-F(s')}{t'-s'}$$\\n\\n‚Ä¢ $F$ is convex $\\Leftrightarrow$ $F$ is absolutely continuous on every compact subinterval and $F'$ is increasing\\n\\n‚Ä¢ If $F$ is convex and $t_0 \\in (a,b)$, then $\\exists \\beta \\in \\mathbb{R}$ such that $F(t) - F(t_0) \\geq \\beta(t - t_0)$ for all $t \\in (a,b)$"
                },

                // Point Set Topology
                {
                    id: 99,
                    category: "Point Set Topology",
                    front: "Define a topology on a set.",
                    back: "Let $X$ be a nonempty set. A **topology** on $X$ is a family $\\mathcal{T}$ of subsets of $X$ such that:\\n\\n‚Ä¢ $\\emptyset, X \\in \\mathcal{T}$\\n\\n‚Ä¢ $\\mathcal{T}$ is closed under arbitrary unions\\n\\n‚Ä¢ $\\mathcal{T}$ is closed under finite intersections\\n\\nThe pair $(X, \\mathcal{T})$ is called a **topological space**. Members of $\\mathcal{T}$ are called **open sets**, and their complements are **closed sets**."
                },
                {
                    id: 100,
                    category: "Point Set Topology",
                    front: "Define interior, closure, and boundary of a set.",
                    back: "If $A \\subset X$ in a topological space:\\n\\n‚Ä¢ **Interior** $A^\\circ$: union of all open sets contained in $A$ (largest open set in $A$)\\n\\n‚Ä¢ **Closure** $\\overline{A}$: intersection of all closed sets containing $A$ (smallest closed set containing $A$)\\n\\n‚Ä¢ **Boundary** $\\partial A = \\overline{A} \\setminus A^\\circ = \\overline{A} \\cap \\overline{A^c}$\\n\\n**Properties**: $(A^\\circ)^c = \\overline{A^c}$ and $(\\overline{A})^c = (A^c)^\\circ$"
                },
                {
                    id: 101,
                    category: "Point Set Topology",
                    front: "Define dense and nowhere dense sets.",
                    back: "In a topological space $X$, a set $A \\subset X$ is:\\n\\n‚Ä¢ **Dense** in $X$ if $\\overline{A} = X$\\n\\n‚Ä¢ **Nowhere dense** if $(\\overline{A})^\\circ = \\emptyset$\\n\ A dense set has closure equal to the whole space, while a nowhere dense set has closure with empty interior."
                },
                {
                    id: 102,
                    category: "Point Set Topology",
                    front: "Define neighborhoods and accumulation points.",
                    back: "In a topological space:\\n\\n‚Ä¢ A **neighborhood** of $x$ (or $E$) is a set $A$ such that $x \\in A^\\circ$ (or $E \\subset A^\\circ$)\\n\\n‚Ä¢ A set $A$ is open $\\Leftrightarrow$ it is a neighborhood of itself\\n\\n‚Ä¢ A point $x$ is an **accumulation point** of $A$ if $A \\cap (U \\setminus \\{x\\}) \\neq \\emptyset$ for every neighborhood $U$ of $x$"
                },
                {
                    id: 103,
                    category: "Point Set Topology",
                    front: "Give examples of common topologies.",
                    back: "On any nonempty set $X$:\\n\\n‚Ä¢ **Discrete topology**: $\\mathcal{P}(X)$ (all subsets are open)\\n\\n‚Ä¢ **Trivial/indiscrete topology**: $\\{\\emptyset, X\\}$\\n\\n‚Ä¢ **Cofinite topology** (if $X$ infinite): $\\{U \\subset X : U = \\emptyset \\text{ or } U^c \\text{ is finite}\\}$\\n\\n‚Ä¢ **Metric topology**: collection of all open sets with respect to a metric\\n\\n‚Ä¢ **Relative topology**: If $Y \\subset X$, then $\\mathcal{T}_Y = \\{U \\cap Y : U \\in \\mathcal{T}\\}$"
                },
                {
                    id: 104,
                    category: "Point Set Topology", 
                    front: "Define weaker/stronger topologies and topology generation.",
                    back: "‚Ä¢ If $\\mathcal{T}_1 \\subseteq \\mathcal{T}_2$ are topologies on $X$, then $\\mathcal{T}_1$ is **weaker/coarser** than $\\mathcal{T}_2$, and $\\mathcal{T}_2$ is **stronger/finer**\\n\\n‚Ä¢ If $\\mathcal{E} \\subset \\mathcal{P}(X)$, the **topology generated by $\\mathcal{E}$** is $\\mathcal{T}(\\mathcal{E}) =$ intersection of all topologies containing $\\mathcal{E}$ (weakest topology containing $\\mathcal{E}$)\\n\\n‚Ä¢ $\\mathcal{T}(\\mathcal{E})$ consists of $\\emptyset$, $X$, and all unions of finite intersections of members of $\\mathcal{E}$"
                },
                {
                    id: 105,
                    category: "Point Set Topology",
                    front: "Define bases and neighborhood bases for topologies.",
                    back: "‚Ä¢ A **neighborhood base** for topology $\\mathcal{T}$ at $x$ is a family $\\mathcal{N} \\subset \\mathcal{T}$ such that:\\n  - $x \\in V$ for all $V \\in \\mathcal{N}$\\n  - If $U \\in \\mathcal{T}$ and $x \\in U$, then $\\exists V \\in \\mathcal{N}$ with $x \\in V \\subseteq U$\\n\\n‚Ä¢ A **base** for $\\mathcal{T}$ is a family $\\mathcal{B} \\subseteq \\mathcal{T}$ that contains a neighborhood base at each $x \\in X$\\n\\n‚Ä¢ $\\mathcal{E}$ is a base for $\\mathcal{T} \\Leftrightarrow$ every nonempty $U \\in \\mathcal{T}$ is a union of members of $\\mathcal{E}$"
                },
                {
                    id: 106,
                    category: "Point Set Topology",
                    front: "Define continuity for functions between topological spaces.",
                    back: "Let $X$ and $Y$ be topological spaces and $f: X \\to Y$.\\n\\n‚Ä¢ $f$ is **continuous** if $f^{-1}(V) \\subseteq X$ is open for every open $V \\subseteq Y$\\n\\n‚Ä¢ $f$ is **continuous at $x$** if for every neighborhood $V$ of $f(x)$, there is a neighborhood $U$ of $x$ such that $f(U) \\subseteq V$\\n\\n Equivalently: $f^{-1}(V)$ is a neighborhood of $x$ for every neighborhood $V$ of $f(x)$"
                },
                {
                    id: 107,
                    category: "Point Set Topology",
                    front: "Define weak topology and product topology.",
                    back: "‚Ä¢ If $X$ is a set and $\\{f_\\alpha: X \\to Y_\\alpha\\}_{\\alpha \\in A}$ are maps to topological spaces, the **weak topology** on $X$ is the weakest topology making all $f_\\alpha$ continuous\\n\\n‚Ä¢ Generated by sets of the form $f_\\alpha^{-1}(U_\\alpha)$ where $U_\\alpha$ is open in $Y_\\alpha$\\n\\n‚Ä¢ The **product topology** on $X = \\prod_\\alpha X_\\alpha$ is the weak topology generated by coordinate maps $\\{\\pi_\\alpha: X \\to X_\\alpha\\}$"
                },
                {
                    id: 108,
                    category: "Point Set Topology",
                    front: "Define function spaces $B(X)$, $C(X)$, $BC(X)$ and the uniform norm.",
                    back: "If $X$ is a topological space and $k = \\mathbb{R}$ or $\\mathbb{C}$:\\n\\n‚Ä¢ $B(X,k) = \\{f: X \\to k \\mid f \\text{ is bounded}\\}$\\n\\n‚Ä¢ $C(X,k) = \\{f: X \\to k \\mid f \\text{ is continuous}\\}$\\n\\n‚Ä¢ $BC(X,k) = B(X,k) \\cap C(X,k)$\\n\\n**Uniform norm**: $\\|f\\|_u = \\sup\\{|f(x)| : x \\in X\\}$\\n\\n$BC(X)$ is a closed subspace of $B(X)$ in the uniform metric, hence complete."
                },
                {
                    id: 109,
                    category: "Point Set Topology",
                    front: "Define normal spaces and state Urysohn's Lemma.",
                    back: "A topological space is **normal** if:\\n\\n‚Ä¢ **$T_1$**: singletons $\\{x\\}$ are closed\\n\\n‚Ä¢ **Closed sets can be separated**: for disjoint closed sets $A$ and $B$, $\\exists$ disjoint open sets $U$ and $V$ with $A \\subset U$, $B \\subset V$\\n\\n**Urysohn's Lemma**: If $X$ is normal and $A$, $B$ are disjoint closed sets, then $\\exists f \\in C(X, [0,1])$ such that $f = 0$ on $A$ and $f = 1$ on $B$."
                },
                {
                    id: 110,
                    category: "Point Set Topology",
                    front: "State the Tietze Extension Theorem.",
                    back: "Let $X$ be a normal space. If $A$ is a closed subset of $X$ and $f \\in C(A, [a,b])$, then $\\exists F \\in C(X, [a,b])$ such that $F|_A = f$.\\n\\n**Corollary**: If $X$ is normal, $A \\subset X$ is closed, and $f \\in C(A)$, then $\\exists F \\in C(X)$ such that $F|_A = f$."
                },
                {
                    id: 111,
                    category: "Point Set Topology",
                    front: "Define compactness and local compactness.",
                    back: "‚Ä¢ A topological space is **compact** if every open cover has a finite subcover\\n\\n‚Ä¢ A topological space $X$ is **locally compact** if every point has a compact neighborhood\\n\\n**Key properties**:\\n‚Ä¢ Closed subset of compact space is compact\\n‚Ä¢ Compact subset of Hausdorff space is closed\\n‚Ä¢ Every compact Hausdorff space is normal\\n‚Ä¢ If $X$ is compact and $f: X \\to Y$ continuous, then $f(X)$ is compact"
                },
                {
                    id: 112,
                    category: "Point Set Topology",
                    front: "Define support, compactly supported functions, and functions vanishing at infinity.",
                    back: "If $X$ is a topological space and $f \\in C(X)$:\\n\\n‚Ä¢ **Support** of $f$: $\\operatorname{supp}(f) =$ closure of $\\{x : f(x) \\neq 0\\}$\\n\\n‚Ä¢ $f$ is **compactly supported** if $\\operatorname{supp}(f)$ is compact\\n  $C_c(X) = \\{f \\in C(X) : \\operatorname{supp}(f) \\text{ is compact}\\}$\\n\\n‚Ä¢ $f$ **vanishes at infinity** if $\\forall \\epsilon > 0$, $\\{x : |f(x)| \\geq \\epsilon\\}$ is compact\\n  $C_0(X) = \\{f \\in C(X) : f \\text{ vanishes at infinity}\\}$\\n\\n**Relationship**: $C_c(X) \\subset C_0(X) \\subset BC(X)$"
                },
                {
                    id: 113,
                    category: "Point Set Topology",
                    front: "State the relationship between $C_c(X)$ and $C_0(X)$ for LCH spaces.",
                    back: "If $X$ is a locally compact Hausdorff (LCH) space, then $C_0(X)$ is the closure of $C_c(X)$ in the uniform metric.\\n\ That is: $\\overline{C_c(X)} = C_0(X)$ in the uniform norm.\\n\\n This shows that compactly supported continuous functions are dense in the space of continuous functions vanishing at infinity."
                }
            ];

            const categoryColors = {
                "Measures": "bg-blue-100 text-blue-800",
                "Integration": "bg-green-100 text-green-800", 
                "Signed Measures": "bg-purple-100 text-purple-800",
                "Functional Analysis": "bg-red-100 text-red-800",
                "Lp Spaces": "bg-yellow-100 text-yellow-800",
                "Haar and Radon Measures": "bg-indigo-100 text-indigo-800",
                "Complex Measures": "bg-teal-100 text-teal-800",
                "Point Set Topology": "bg-pink-100 text-pink-800"
            };

            function FlashcardApp() {
                const [currentIndex, setCurrentIndex] = useState(0);
                const [showAnswer, setShowAnswer] = useState(false);
                const [selectedCategories, setSelectedCategories] = useState(new Set(Object.keys(categoryColors)));
                const [filteredCards, setFilteredCards] = useState(flashcardsData);
                const [progress, setProgress] = useState({});
                const [showProgress, setShowProgress] = useState(false);
                const [isShuffled, setIsShuffled] = useState(false);
                const [shuffledIndices, setShuffledIndices] = useState([]);
                const [isDarkMode, setIsDarkMode] = useState(true);
                const [reviewMode, setReviewMode] = useState(false);
                const [showReviewPrompt, setShowReviewPrompt] = useState(false);
                const [deckCompleted, setDeckCompleted] = useState(false);
                const [showCelebration, setShowCelebration] = useState(false);

                const categories = Object.keys(categoryColors);

                // Apply dark mode to entire page body
                useEffect(() => {
                    document.body.className = isDarkMode ? 'bg-gray-900' : 'bg-gray-50';
                }, [isDarkMode]);

                // Configure and trigger MathJax rendering
                useEffect(() => {
                    const renderMath = async () => {
                        if (window.MathJax && window.MathJax.typesetPromise) {
                            try {
                                // Clear any existing MathJax processing first
                                if (window.MathJax.typesetClear) {
                                    window.MathJax.typesetClear();
                                }
                                // Add a small delay to let React finish DOM updates
                                await new Promise(resolve => setTimeout(resolve, 10));
                                await window.MathJax.typesetPromise();
                            } catch (err) {
                                console.log('MathJax rendering error:', err);
                                // Try to recover by clearing MathJax state
                                try {
                                    if (window.MathJax.startup && window.MathJax.startup.document) {
                                        window.MathJax.startup.document.state(0);
                                    }
                                } catch (recoveryErr) {
                                    console.log('MathJax recovery failed:', recoveryErr);
                                }
                            }
                        }
                    };
                    renderMath();
                }, [currentIndex, showAnswer, filteredCards]);

                useEffect(() => {
                    const filtered = flashcardsData.filter(card => selectedCategories.has(card.category));
                    setFilteredCards(filtered);
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setIsShuffled(false);
                    setShuffledIndices([]);
                    setReviewMode(false);
                    setShowReviewPrompt(false);
                    setDeckCompleted(false);
                    setShowCelebration(false);
                }, [selectedCategories]);

                // Fisher-Yates shuffle algorithm
                const shuffleArray = (array) => {
                    const shuffled = [...array];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    return shuffled;
                };

                const currentCard = isShuffled && shuffledIndices.length > 0 
                    ? filteredCards[shuffledIndices[currentIndex]] 
                    : filteredCards[currentIndex];

                const nextCard = () => {
                    if (currentIndex < filteredCards.length - 1) {
                        setCurrentIndex(currentIndex + 1);
                        setShowAnswer(false);
                    } else {
                        // Reached end of deck
                        setDeckCompleted(true);
                        triggerCelebration(); // üéâ Trigger celebration animation!
                        
                        const incorrectCards = getIncorrectCards();
                        if (incorrectCards.length > 0 && !reviewMode) {
                            // Delay showing the review prompt to let celebration play
                            setTimeout(() => {
                                setShowReviewPrompt(true);
                            }, 1500);
                        }
                    }
                };

                const prevCard = () => {
                    if (currentIndex > 0) {
                        setCurrentIndex(currentIndex - 1);
                        setShowAnswer(false);
                    }
                };

                const resetDeck = () => {
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setIsShuffled(false);
                    setShuffledIndices([]);
                    setDeckCompleted(false);
                    setShowReviewPrompt(false);
                    setShowCelebration(false);
                };

                const shuffleDeck = () => {
                    if (filteredCards.length > 0) {
                        const indices = Array.from({length: filteredCards.length}, (_, i) => i);
                        const shuffled = shuffleArray(indices);
                        setShuffledIndices(shuffled);
                        setIsShuffled(true);
                        setCurrentIndex(0);
                        setShowAnswer(false);
                    }
                };

                const toggleCategory = (category) => {
                    const newSelected = new Set(selectedCategories);
                    if (newSelected.has(category)) {
                        newSelected.delete(category);
                    } else {
                        newSelected.add(category);
                    }
                    setSelectedCategories(newSelected);
                };

                const toggleDarkMode = () => {
                    setIsDarkMode(!isDarkMode);
                };

                const markCard = (correct) => {
                    if (currentCard) {
                        setProgress(prev => ({
                            ...prev,
                            [currentCard.id]: correct
                        }));
                    }
                };

                const getProgressStats = () => {
                    const correct = Object.values(progress).filter(Boolean).length;
                    const total = Object.keys(progress).length;
                    return { correct, total };
                };

                const getIncorrectCards = () => {
                    return flashcardsData.filter(card => 
                        selectedCategories.has(card.category) && 
                        progress[card.id] === false
                    );
                };

                const startReviewMode = () => {
                    const incorrectCards = getIncorrectCards();
                    setFilteredCards(incorrectCards);
                    setReviewMode(true);
                    setShowReviewPrompt(false);
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setDeckCompleted(false);
                    setIsShuffled(false);
                    setShuffledIndices([]);
                };

                const exitReviewMode = () => {
                    const filtered = flashcardsData.filter(card => selectedCategories.has(card.category));
                    setFilteredCards(filtered);
                    setReviewMode(false);
                    setShowReviewPrompt(false);
                    setCurrentIndex(0);
                    setShowAnswer(false);
                    setDeckCompleted(false);
                    setIsShuffled(false);
                    setShuffledIndices([]);
                };

                const triggerCelebration = () => {
                    setShowCelebration(true);
                    // Hide celebration after 4 seconds
                    setTimeout(() => {
                        setShowCelebration(false);
                    }, 4000);
                };

                const createConfetti = () => {
                    const confettiElements = [];
                    const confettiEmojis = ['üéâ', 'üéä', '‚≠ê', '‚ú®', 'üåü', 'üí´', 'üéà', 'üéÜ', 'üéá', 'üåà', 'üéÅ', 'üçæ', 'ü•≥', 'üå∫', 'ü¶Ñ', 'üéÄ'];
                    
                    // Create explosive burst from center
                    for (let i = 0; i < 80; i++) {
                        const delay = Math.random() * 800;
                        const angle = (Math.PI * 2 * i) / 80 + Math.random() * 0.5;
                        const velocity = 300 + Math.random() * 400;
                        const endX = Math.cos(angle) * velocity;
                        const endY = Math.sin(angle) * velocity;
                        
                        const emoji = confettiEmojis[Math.floor(Math.random() * confettiEmojis.length)];
                        const size = 20 + Math.random() * 15;
                        
                        // Create unique keyframes for each confetti piece
                        const animationName = `explode-${i}`;
                        const keyframes = `
                            @keyframes ${animationName} {
                                0% {
                                    transform: translate(-50%, -50%) scale(0) rotate(0deg);
                                    opacity: 1;
                                }
                                15% {
                                    transform: translate(-50%, -50%) scale(1.2) rotate(180deg);
                                    opacity: 1;
                                }
                                100% {
                                    transform: translate(calc(-50% + ${endX}px), calc(-50% + ${endY}px)) scale(0.3) rotate(720deg);
                                    opacity: 0;
                                }
                            }
                        `;
                        
                        // Add keyframes to document
                        if (!document.getElementById(`style-${animationName}`)) {
                            const style = document.createElement('style');
                            style.id = `style-${animationName}`;
                            style.textContent = keyframes;
                            document.head.appendChild(style);
                        }
                        
                        confettiElements.push(
                            React.createElement('div', {
                                key: i,
                                className: 'confetti',
                                style: {
                                    left: '50%',
                                    top: '50%',
                                    fontSize: `${size}px`,
                                    animation: `${animationName} 2.5s ease-out forwards`,
                                    animationDelay: `${delay}ms`
                                }
                            }, emoji)
                        );
                    }
                    
                    // Add secondary bursts from corners
                    const burstPoints = [
                        { x: '20%', y: '20%' },
                        { x: '80%', y: '20%' },
                        { x: '20%', y: '80%' },
                        { x: '80%', y: '80%' }
                    ];
                    
                    burstPoints.forEach((point, pointIndex) => {
                        for (let i = 0; i < 15; i++) {
                            const delay = 600 + Math.random() * 1000;
                            const angle = Math.random() * Math.PI * 2;
                            const velocity = 150 + Math.random() * 250;
                            const endX = Math.cos(angle) * velocity;
                            const endY = Math.sin(angle) * velocity;
                            
                            const emoji = confettiEmojis[Math.floor(Math.random() * confettiEmojis.length)];
                            const size = 15 + Math.random() * 10;
                            
                            const animationName = `burst-${pointIndex}-${i}`;
                            const keyframes = `
                                @keyframes ${animationName} {
                                    0% {
                                        transform: scale(0) rotate(0deg);
                                        opacity: 1;
                                    }
                                    20% {
                                        transform: scale(1.1) rotate(180deg);
                                        opacity: 1;
                                    }
                                    100% {
                                        transform: translate(${endX}px, ${endY}px) scale(0.2) rotate(540deg);
                                        opacity: 0;
                                    }
                                }
                            `;
                            
                            if (!document.getElementById(`style-${animationName}`)) {
                                const style = document.createElement('style');
                                style.id = `style-${animationName}`;
                                style.textContent = keyframes;
                                document.head.appendChild(style);
                            }
                            
                            confettiElements.push(
                                React.createElement('div', {
                                    key: `burst-${pointIndex}-${i}`,
                                    className: 'confetti',
                                    style: {
                                        left: point.x,
                                        top: point.y,
                                        fontSize: `${size}px`,
                                        animation: `${animationName} 2s ease-out forwards`,
                                        animationDelay: `${delay}ms`
                                    }
                                }, emoji)
                            );
                        }
                    });
                    
                    return confettiElements;
                };

                const formatText = (text) => {
                    if (!text) return '';
                    
                    // Convert \\n to actual newlines, but be careful not to break LaTeX commands
                    // Only replace \\n when it's NOT followed by a letter (to avoid breaking \\nu, \\nabla, etc.)
                    const processedText = text.replace(/\\n(?![a-zA-Z])/g, '\n');
                    
                    // Split by lines but preserve display math blocks
                    const lines = [];
                    let currentBlock = '';
                    let inDisplayMath = false;
                    
                    for (const line of processedText.split('\n')) {
                        if (line.includes('$$')) {
                            const dollarsCount = (line.match(/\$\$/g) || []).length;
                            if (dollarsCount === 2) {
                                // Line contains both opening and closing $$
                                lines.push(currentBlock);
                                lines.push(line);
                                currentBlock = '';
                            } else if (dollarsCount === 1) {
                                if (inDisplayMath) {
                                    // Closing display math
                                    currentBlock += '\n' + line;
                                    lines.push(currentBlock);
                                    currentBlock = '';
                                    inDisplayMath = false;
                                } else {
                                    // Opening display math
                                    if (currentBlock.trim()) {
                                        lines.push(currentBlock);
                                    }
                                    currentBlock = line;
                                    inDisplayMath = true;
                                }
                            }
                        } else if (inDisplayMath) {
                            currentBlock += '\n' + line;
                        } else {
                            if (currentBlock) {
                                currentBlock += '\n' + line;
                            } else {
                                currentBlock = line;
                            }
                            if (!inDisplayMath && currentBlock.trim()) {
                                lines.push(currentBlock);
                                currentBlock = '';
                            }
                        }
                    }
                    
                    if (currentBlock.trim()) {
                        lines.push(currentBlock);
                    }
                    
                    return lines.map((block, blockIndex) => {
                        if (!block || block.trim() === '') {
                            return React.createElement('div', { key: blockIndex, className: "h-2" });
                        }
                        
                        // Handle display math blocks ($$...$$)
                        if (block.includes('$$')) {
                            return React.createElement('div', { 
                                key: blockIndex, 
                                className: "mb-4 text-center" 
                            }, block);
                        }
                        
                        // Process block line by line
                        return block.split('\n').map((line, lineIndex) => {
                            const key = `${blockIndex}-${lineIndex}`;
                            
                            // Skip empty lines but add spacing
                            if (line.trim() === '') {
                                return React.createElement('div', { key, className: "h-2" });
                            }
                            
                            // Handle **bold** formatting
                            const processBoldText = (text) => {
                                if (!text || typeof text !== 'string') return text;
                                
                                const parts = [];
                                let lastIndex = 0;
                                const boldRegex = /\*\*([^*]+)\*\*/g;
                                let match;
                                
                                while ((match = boldRegex.exec(text)) !== null) {
                                    // Add text before the bold part
                                    if (match.index > lastIndex) {
                                        parts.push(text.substring(lastIndex, match.index));
                                    }
                                    // Add the bold part
                                    parts.push(React.createElement('strong', { key: `bold-${match.index}` }, match[1]));
                                    lastIndex = match.index + match[0].length;
                                }
                                // Add remaining text
                                if (lastIndex < text.length) {
                                    parts.push(text.substring(lastIndex));
                                }
                                
                                return parts.length > 1 ? parts : text;
                            };
                            
                            // Handle bullet points
                            const bulletMatch = line.match(/^(\s*)(‚Ä¢|\*|-)\s+(.*)$/);
                            if (bulletMatch) {
                                return React.createElement('div', { 
                                    key, 
                                    className: "mb-2 flex items-start" 
                                }, [
                                    React.createElement('span', { 
                                        key: 'bullet',
                                        className: "mr-3 flex-shrink-0 text-blue-600" 
                                    }, '‚Ä¢'),
                                    React.createElement('div', { 
                                        key: 'content',
                                        className: "flex-1"
                                    }, processBoldText(bulletMatch[3]))
                                ]);
                            }
                            
                            // Handle numbered items like "1. content"  
                            const numberMatch = line.match(/^(\d+\.\s*)(.*)$/);
                            if (numberMatch) {
                                return React.createElement('div', { 
                                    key, 
                                    className: "mb-3 flex items-start" 
                                }, [
                                    React.createElement('span', { 
                                        key: 'number',
                                        className: "font-bold mr-3 flex-shrink-0 text-blue-600 min-w-6" 
                                    }, numberMatch[1]),
                                    React.createElement('div', { 
                                        key: 'content',
                                        className: "flex-1"
                                    }, processBoldText(numberMatch[2]))
                                ]);
                            }
                            
                            // Regular lines
                            return React.createElement('div', { key, className: "mb-1" }, processBoldText(line));
                        });
                    }).flat().filter(Boolean);
                };

                if (filteredCards.length === 0) {
                    const themeClasses = {
                        body: isDarkMode ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-900',
                        text: {
                            primary: isDarkMode ? 'text-white' : 'text-gray-800',
                            secondary: isDarkMode ? 'text-gray-300' : 'text-gray-600',
                        },
                        button: {
                            secondary: isDarkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300',
                        }
                    };

                    return React.createElement('div', { className: `max-w-4xl mx-auto p-6 min-h-screen ${themeClasses.body}` },
                        React.createElement('div', { className: "mb-6" },
                            React.createElement('div', { className: "flex justify-between items-center mb-4" },
                                React.createElement('div', { className: "flex-1" },
                                    React.createElement('h1', { className: `text-3xl font-bold ${themeClasses.text.primary} text-center` },
                                        "Real Analysis Flashcards"
                                    )
                                ),
                                React.createElement('button', {
                                    onClick: toggleDarkMode,
                                    className: `p-2 rounded-lg ${themeClasses.button.secondary} text-lg`
                                }, isDarkMode ? Sun() : Moon())
                            ),
                            
                            // Category Filter
                            React.createElement('div', { className: "mb-4" },
                                React.createElement('h3', { className: `text-lg font-medium ${themeClasses.text.primary} mb-2` }, 
                                    "Select Categories:"),
                                React.createElement('div', { className: "flex flex-wrap gap-2" },
                                    categories.map(category => 
                                        React.createElement('button', {
                                            key: category,
                                            onClick: () => toggleCategory(category),
                                            className: `px-3 py-1 rounded-full text-sm font-medium transition-all ${
                                                selectedCategories.has(category) 
                                                    ? categoryColors[category] 
                                                    : 'bg-gray-200 text-gray-500'
                                            }`
                                        }, category)
                                    )
                                )
                            ),
                            
                            React.createElement('div', { className: "text-center mt-8" },
                                React.createElement('p', { className: `${themeClasses.text.secondary} text-lg` }, 
                                    "Please select at least one category to study.")
                            )
                        )
                    );
                }

                if (!currentCard) {
                    return React.createElement('div', { className: `max-w-4xl mx-auto p-6 min-h-screen ${isDarkMode ? 'bg-gray-900' : 'bg-gray-50'}` },
                        React.createElement('div', { className: "text-center" },
                            React.createElement('h1', { className: `text-3xl font-bold ${isDarkMode ? 'text-white' : 'text-gray-800'} mb-4` }, 
                                "Real Analysis Flashcards"),
                            React.createElement('p', { className: isDarkMode ? 'text-gray-300' : 'text-gray-600' }, "Loading cards...")
                        )
                    );
                }

                const { correct, total } = getProgressStats();

                // Theme-aware classes
                const themeClasses = {
                    body: isDarkMode ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-900',
                    card: isDarkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-900',
                    cardContent: isDarkMode ? 'bg-gray-700' : 'bg-gray-50',
                    text: {
                        primary: isDarkMode ? 'text-white' : 'text-gray-800',
                        secondary: isDarkMode ? 'text-gray-300' : 'text-gray-600',
                        muted: isDarkMode ? 'text-gray-400' : 'text-gray-500'
                    },
                    button: {
                        primary: isDarkMode ? 'bg-blue-700 hover:bg-blue-800' : 'bg-blue-600 hover:bg-blue-700',
                        secondary: isDarkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300',
                        nav: isDarkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-600 hover:bg-gray-700',
                        purple: isDarkMode ? 'bg-purple-700 hover:bg-purple-800' : 'bg-purple-600 hover:bg-purple-700',
                        green: isDarkMode ? 'bg-green-700 hover:bg-green-800' : 'bg-green-100 hover:bg-green-200',
                        greenActive: isDarkMode ? 'bg-green-800' : 'bg-green-600',
                        red: isDarkMode ? 'bg-red-700 hover:bg-red-800' : 'bg-red-100 hover:bg-red-200',
                        redActive: isDarkMode ? 'bg-red-800' : 'bg-red-600'
                    },
                    progressBar: isDarkMode ? 'bg-gray-700' : 'bg-gray-200',
                    progressFill: isDarkMode ? 'bg-blue-500' : 'bg-blue-600'
                };

                return React.createElement('div', { className: `max-w-4xl mx-auto p-6 min-h-screen ${themeClasses.body}` },
                    React.createElement('div', { className: "mb-6" },
                        React.createElement('div', { className: "flex justify-between items-center mb-4" },
                            React.createElement('div', { className: "flex-1" },
                                React.createElement('h1', { className: `text-3xl font-bold ${themeClasses.text.primary} text-center` },
                                    "Real Analysis Flashcards"
                                ),
                                reviewMode && React.createElement('div', { className: `text-center text-sm ${themeClasses.text.secondary} mt-1` },
                                    "üìù Review Mode - Incorrect Cards Only"
                                )
                            ),
                            React.createElement('button', {
                                onClick: toggleDarkMode,
                                className: `p-2 rounded-lg ${themeClasses.button.secondary} ${themeClasses.text.primary} transition-colors`,
                                title: isDarkMode ? 'Switch to light mode' : 'Switch to dark mode'
                            },
                                React.createElement(isDarkMode ? Sun : Moon, { size: 20 })
                            )
                        ),
                        
                        // Category Filter
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('h3', { className: `text-lg font-medium ${themeClasses.text.primary} mb-2` }, 
                                "Select Categories:"),
                            React.createElement('div', { className: "flex flex-wrap gap-2" },
                                categories.map(category => 
                                    React.createElement('button', {
                                        key: category,
                                        onClick: () => toggleCategory(category),
                                        className: `px-3 py-1 rounded-full text-sm font-medium transition-all ${
                                            selectedCategories.has(category) 
                                                ? categoryColors[category] 
                                                : 'bg-gray-200 text-gray-500'
                                        }`
                                    }, category)
                                )
                            )
                        ),

                        // Controls Row
                        React.createElement('div', { className: "flex justify-between items-center mb-2" },
                            React.createElement('div', { className: `text-sm ${themeClasses.text.secondary}` },
                                `Card ${currentIndex + 1} of ${filteredCards.length}`,
                                isShuffled && React.createElement('span', { className: `ml-2 ${isDarkMode ? 'text-purple-400' : 'text-purple-600'}` }, "(Shuffled)")
                            ),
                            React.createElement('div', { className: "flex items-center gap-2" },
                                !reviewMode && React.createElement('button', {
                                    onClick: shuffleDeck,
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.purple} text-white rounded-lg text-sm transition-colors`
                                },
                                    React.createElement(Shuffle, { size: 16 }),
                                    "Shuffle"
                                ),
                                !reviewMode && getIncorrectCards().length > 0 && React.createElement('button', {
                                    onClick: startReviewMode,
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.red} ${isDarkMode ? 'text-red-300' : 'text-red-600'} rounded-lg text-sm transition-colors`
                                },
                                    React.createElement('span', null, 'üìù'),
                                    "Review Wrong"
                                ),
                                reviewMode && React.createElement('button', {
                                    onClick: exitReviewMode,
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.secondary} rounded-lg text-sm ${themeClasses.text.primary}`
                                },
                                    React.createElement('span', null, '‚Üê'),
                                    "Exit Review"
                                ),
                                React.createElement('button', {
                                    onClick: () => setShowProgress(!showProgress),
                                    className: `flex items-center gap-2 px-3 py-1 ${themeClasses.button.secondary} rounded-lg text-sm ${themeClasses.text.primary}`
                                },
                                    React.createElement(showProgress ? EyeOff : Eye, { size: 16 }),
                                    "Progress"
                                )
                            )
                        ),

                        // Progress Stats
                        showProgress && React.createElement('div', { className: `mt-2 p-3 ${themeClasses.card} rounded-lg` },
                            React.createElement('div', { className: `text-sm ${themeClasses.text.secondary}` },
                                `Progress: ${correct}/${total} correct`,
                                total > 0 && React.createElement('span', { className: "ml-2" },
                                    `(${Math.round((correct / total) * 100)}%)`
                                )
                            )
                        )
                    ),

                    // Main Card
                    React.createElement('div', { className: `${themeClasses.card} rounded-xl shadow-lg p-8 mb-6 min-h-[400px] flex flex-col` },
                        // Category Badge
                        React.createElement('div', { className: "mb-4" },
                            React.createElement('span', { 
                                className: `inline-block px-3 py-1 rounded-full text-sm font-medium ${categoryColors[currentCard.category]}`
                            }, currentCard.category)
                        ),

                        // Card Content
                        React.createElement('div', { className: "flex-1 flex flex-col justify-center" },
                            React.createElement('div', { className: "text-center mb-6" },
                                React.createElement('div', { className: `text-2xl font-bold ${themeClasses.text.primary} mb-4` },
                                    showAnswer ? 'Answer' : 'Question'
                                ),
                                React.createElement('div', { 
                                    className: `text-lg ${themeClasses.text.primary} text-left ${themeClasses.cardContent} p-6 rounded-lg tex2jax_process`,
                                    key: `card-content-${currentCard.id}-${showAnswer}` // Force re-render on content change
                                },
                                    formatText(showAnswer ? currentCard.back : currentCard.front)
                                )
                            ),

                            // Show/Hide Answer Button
                            React.createElement('div', { className: "text-center" },
                                React.createElement('button', {
                                    onClick: () => setShowAnswer(!showAnswer),
                                    className: `${themeClasses.button.primary} text-white font-medium py-3 px-6 rounded-lg transition-colors flex items-center gap-2 mx-auto`
                                },
                                    React.createElement(BookOpen, { size: 20 }),
                                    showAnswer ? 'Hide Answer' : 'Show Answer'
                                )
                            )
                        ),

                        // Progress Tracking
                        showAnswer && React.createElement('div', { className: "mt-6 flex justify-center gap-4" },
                            React.createElement('button', {
                                onClick: () => markCard(false),
                                className: `flex items-center gap-2 px-4 py-2 rounded-lg transition-colors ${
                                    progress[currentCard.id] === false 
                                        ? `${themeClasses.button.redActive} text-white` 
                                        : `${themeClasses.button.red} ${isDarkMode ? 'text-red-300' : 'text-red-600'}`
                                }`
                            },
                                React.createElement(X, { size: 16 }),
                                "Incorrect"
                            ),
                            React.createElement('button', {
                                onClick: () => markCard(true),
                                className: `flex items-center gap-2 px-4 py-2 rounded-lg transition-colors ${
                                    progress[currentCard.id] === true 
                                        ? `${themeClasses.button.greenActive} text-white` 
                                        : `${themeClasses.button.green} ${isDarkMode ? 'text-green-300' : 'text-green-600'}`
                                }`
                            },
                                React.createElement(Check, { size: 16 }),
                                "Correct"
                            )
                        )
                    ),

                    // Navigation Controls
                    React.createElement('div', { className: "flex justify-between items-center" },
                        React.createElement('button', {
                            onClick: prevCard,
                            disabled: currentIndex === 0,
                            className: `flex items-center gap-2 px-4 py-2 ${themeClasses.button.nav} text-white rounded-lg disabled:${isDarkMode ? 'bg-gray-800' : 'bg-gray-300'} disabled:cursor-not-allowed transition-colors`
                        },
                            React.createElement(ChevronLeft, { size: 20 }),
                            "Previous"
                        ),

                        React.createElement('button', {
                            onClick: resetDeck,
                            className: `flex items-center gap-2 px-4 py-2 ${themeClasses.button.purple} text-white rounded-lg transition-colors`
                        },
                            React.createElement(RotateCcw, { size: 20 }),
                            "Reset"
                        ),

                        currentIndex === filteredCards.length - 1 
                            ? React.createElement('button', {
                                onClick: () => {
                                    // Trigger celebration and completion logic
                                    setDeckCompleted(true);
                                    triggerCelebration();
                                    
                                    const incorrectCards = getIncorrectCards();
                                    if (incorrectCards.length > 0 && !reviewMode) {
                                        setTimeout(() => {
                                            setShowReviewPrompt(true);
                                        }, 1500);
                                    }
                                },
                                className: `flex items-center gap-2 px-4 py-2 ${themeClasses.button.primary} text-white rounded-lg transition-colors`
                            },
                                "Finish Deck üéâ",
                                React.createElement(Check, { size: 20 })
                            )
                            : React.createElement('button', {
                                onClick: nextCard,
                                className: `flex items-center gap-2 px-4 py-2 ${themeClasses.button.nav} text-white rounded-lg transition-colors`
                            },
                                "Next",
                                React.createElement(ChevronRight, { size: 20 })
                            )
                    ),

                    // Progress Bar
                    React.createElement('div', { className: "mt-6" },
                        React.createElement('div', { className: `${themeClasses.progressBar} rounded-full h-2` },
                            React.createElement('div', {
                                className: `${themeClasses.progressFill} h-2 rounded-full transition-all duration-300`,
                                style: { width: `${((currentIndex + 1) / filteredCards.length) * 100}%` }
                            })
                        )
                    ),

                    // Stats Footer
                    React.createElement('div', { className: `mt-4 text-center text-sm ${themeClasses.text.secondary}` },
                        `Total Cards: ${flashcardsData.length} | Filtered: ${filteredCards.length}`
                    ),

                    // Celebration Animation
                    showCelebration && React.createElement('div', { 
                        className: "celebration-overlay"
                    }, createConfetti()),

                    // Review Prompt Modal
                    showReviewPrompt && React.createElement('div', { 
                        className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50",
                        onClick: () => setShowReviewPrompt(false)
                    },
                        React.createElement('div', { 
                            className: `${themeClasses.card} p-8 rounded-lg shadow-xl max-w-md mx-4`,
                            onClick: (e) => e.stopPropagation()
                        },
                            React.createElement('h2', { className: `text-2xl font-bold ${themeClasses.text.primary} mb-4 text-center` },
                                "üéâ Deck Complete!"
                            ),
                            React.createElement('div', { className: `${themeClasses.text.secondary} mb-6 text-center` },
                                `You got ${getIncorrectCards().length} cards wrong. Would you like to review them?`
                            ),
                            React.createElement('div', { className: "flex gap-3 justify-center" },
                                React.createElement('button', {
                                    onClick: () => setShowReviewPrompt(false),
                                    className: `px-4 py-2 ${themeClasses.button.secondary} rounded-lg ${themeClasses.text.primary} transition-colors`
                                }, "Skip"),
                                React.createElement('button', {
                                    onClick: startReviewMode,
                                    className: `px-4 py-2 ${themeClasses.button.primary} text-white rounded-lg transition-colors`
                                }, "Review Wrong Cards")
                            )
                        )
                    )
                );
            }

            ReactDOM.render(React.createElement(FlashcardApp), document.getElementById('root'));

        } catch (error) {
            console.error('Error in React app:', error);
            document.getElementById('root').innerHTML = '<div class="error">Error loading app: ' + error.message + '</div>';
        }
    </script>
</body>
</html>